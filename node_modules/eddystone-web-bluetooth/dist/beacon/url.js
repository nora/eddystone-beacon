"use strict";
/**
 * https://github.com/google/eddystone/tree/master/eddystone-url
 */
Object.defineProperty(exports, "__esModule", { value: true });
var text_encoding_1 = require("text-encoding");
var URL_SCHEMES = {
    0x00: 'http://www.',
    0x01: 'https://www.',
    0x02: 'http://',
    0x03: 'https://',
};
var URL_CODES = {
    0x00: '.com/',
    0x01: '.org/',
    0x02: '.edu/',
    0x03: '.net/',
    0x04: '.info/',
    0x05: '.biz/',
    0x06: '.gov/',
    0x07: '.com',
    0x08: '.org',
    0x09: '.edu',
    0x0a: '.net',
    0x0b: '.info',
    0x0c: '.biz',
    0x0d: '.gov',
};
function decodeUrl(raw) {
    var scheme = URL_SCHEMES[raw.getUint8(0)];
    var url = Array.from(Array(raw.byteLength).keys())
        .slice(1)
        .map(function (bytePos) {
        var byteVal = raw.getUint8(bytePos);
        return URL_CODES[byteVal] || String.fromCharCode(byteVal);
    })
        .join('');
    return "" + scheme + url;
}
exports.decodeUrl = decodeUrl;
function encodeUrl(val) {
    var encoder = new text_encoding_1.TextEncoder('utf-8');
    var encoded = [];
    for (var i = 0; i < val.length; i += 1) {
        // Try shorten the result as much as possible by using the above references.
        var shortEncoded = shortEncode(val.slice(i));
        if (shortEncoded) {
            encoded.push(shortEncoded.code);
            i += shortEncoded.jump - 1;
            continue;
        }
        // If it can't be shortened, simply encode the character.
        encoded.push(encoder.encode(val[i])[0]);
    }
    var buffer = new ArrayBuffer(encoded.length);
    var raw = new DataView(buffer);
    encoded.forEach(function (character, i) { return raw.setUint8(i, character); });
    return raw;
}
exports.encodeUrl = encodeUrl;
function shortEncode(val) {
    return shortEncodeWithDict(val, URL_SCHEMES)
        || shortEncodeWithDict(val, URL_CODES);
}
function shortEncodeWithDict(val, hexTypes) {
    var matching = Object.keys(hexTypes).filter(function (codeIndex) {
        var code = Number(codeIndex);
        return val.startsWith(hexTypes[code]);
    });
    if (matching.length === 0) {
        return undefined;
    }
    matching.sort();
    var bestMatch = Number(matching[0]);
    return {
        code: bestMatch,
        jump: hexTypes[bestMatch].length,
    };
}
//# sourceMappingURL=url.js.map